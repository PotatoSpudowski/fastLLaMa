import{O as v,P as g,Q as y}from"./index-5ed67125.js";class b{constructor(e={}){this.warmUpDelay=1e3,this.coolDownDelay=1e3,this.isWarm=!1,this.timeout=0,Object.assign(this,e)}async openTimer(e){if(this.cancelCooldownTimer(),!this.component||e!==this.component)return this.component&&(this.close(this.component),this.cancelCooldownTimer()),this.component=e,this.isWarm?!1:(this.promise=new Promise(t=>{this.resolve=t,this.timeout=window.setTimeout(()=>{this.resolve&&(this.resolve(!1),this.isWarm=!0)},this.warmUpDelay)}),this.promise);if(this.promise)return this.promise;throw new Error("Inconsistent state")}close(e){this.component&&this.component===e&&(this.resetCooldownTimer(),this.timeout>0&&(clearTimeout(this.timeout),this.timeout=0),this.resolve&&(this.resolve(!0),delete this.resolve),delete this.promise,delete this.component)}resetCooldownTimer(){this.isWarm&&(this.cooldownTimeout&&window.clearTimeout(this.cooldownTimeout),this.cooldownTimeout=window.setTimeout(()=>{this.isWarm=!1,delete this.cooldownTimeout},this.coolDownDelay))}cancelCooldownTimer(){this.cooldownTimeout&&window.clearTimeout(this.cooldownTimeout),delete this.cooldownTimeout}}const f=(s,e)=>{let t=document.elementFromPoint(s,e);for(;t!=null&&t.shadowRoot;){const o=t.shadowRoot.elementFromPoint(s,e);if(!o||o===t)break;t=o}return t};function w(s){return s.button===0}function C(s){return!!(s.metaKey||s.altKey||s.ctrlKey||s.shiftKey)}function u(){return new Promise(s=>requestAnimationFrame(()=>s()))}class T{constructor(){this.overlays=[],this.preventMouseRootClose=!1,this.root=document.body,this.handlingResize=!1,this.overlayTimer=new b,this.canTabTrap=!0,this.trappingInited=!1,this._eventsAreBound=!1,this._bodyMarginsApplied=!1,this.forwardContextmenuEvent=async e=>{var t;const o=this.overlays[this.overlays.length-1];!this.trappingInited||o.interaction!=="modal"||e.target!==this.overlayHolder||(e.stopPropagation(),e.preventDefault(),await this.closeTopOverlay(),(t=f(e.clientX,e.clientY))==null||t.dispatchEvent(new MouseEvent("contextmenu",e)))},this.handleOverlayClose=e=>{const{root:t}=e;t&&this.closeOverlaysForRoot(t)},this.handleMouseCapture=e=>{const t=this.topOverlay;if(!e.target||!t||!t.overlayContent||C(e)||!w(e)){this.preventMouseRootClose=!0;return}if(e.target instanceof Node){if(e.composedPath().indexOf(t.overlayContent)>=0){this.preventMouseRootClose=!0;return}this.preventMouseRootClose=!1}},this._doesNotCloseOnFirstClick=!1,this.handleMouse=e=>{var t;if(this._doesNotCloseOnFirstClick){this._doesNotCloseOnFirstClick=!1;return}if(this.preventMouseRootClose||e.defaultPrevented)return;const o=[];let i=this.overlays.length;for(;i&&o.length===0;){i-=1;const a=this.overlays[i],l=e.composedPath();(!l.includes(a.trigger)||a.interaction!=="hover")&&!l.includes(a.overlayContent)&&o.push(a)}let r=(t=this.topOverlay)==null?void 0:t.root,n=v(r);for(;r&&n;)o.push(n),n=v(r),r=n==null?void 0:n.root;n&&o.push(n),o.forEach(a=>this.hideAndCloseOverlay(a))},this.handleKeydown=e=>{e.code==="Escape"&&this.closeTopOverlay()},this.handleResize=()=>{this.handlingResize||(this.handlingResize=!0,requestAnimationFrame(async()=>{const e=this.overlays.map(t=>t.updateOverlayPosition());await Promise.all(e),this.handlingResize=!1}))},this.initTabTrapping()}initTabTrapping(){if(document.readyState==="loading"){document.addEventListener("readystatechange",()=>{this.initTabTrapping()},{once:!0});return}if(this.trappingInited)return;if(this.trappingInited=!0,this.document.body.shadowRoot){this.canTabTrap=!1;return}if(this.document.body.attachShadow({mode:"open"}),!this.document.body.shadowRoot)return;const e=this.document.body.shadowRoot;e.innerHTML=`
            <style>
            :host {
                position: relative;
            }
            #actual {
                position: relative;
                height: calc(100% - var(--swc-body-margins-block, 0px));
                z-index: 0;
                min-height: calc(100vh - var(--swc-body-margins-block, 0px));
            }
            #holder {
                display: none;
                align-items: center;
                justify-content: center;
                flex-flow: column;
                width: 100%;
                height: 100%;
                position: absolute;
                top: 0;
                left: 0;
            }
            [name="open"]::slotted(*) {
                pointer-events: all;
            }
            #actual[aria-hidden] + #holder {
                display: flex;
            }
            </style>
            <div id="actual"><slot></slot></div>
            <div id="holder"><slot name="open"></slot></div>
        `,this.tabTrapper=e.querySelector("#actual"),this.overlayHolder=e.querySelector("#holder"),this.tabTrapper.attachShadow({mode:"open"}),this.tabTrapper.shadowRoot&&(this.tabTrapper.shadowRoot.innerHTML="<slot></slot>"),this.overlayHolder.addEventListener("contextmenu",this.forwardContextmenuEvent,!0),requestAnimationFrame(()=>{this.applyBodyMargins(),new ResizeObserver(()=>{this.applyBodyMargins()}).observe(document.body)})}applyBodyMargins(){const{marginLeft:e,marginRight:t,marginTop:o,marginBottom:i}=getComputedStyle(document.body),r=parseFloat(e)===0&&parseFloat(t)===0&&parseFloat(o)===0&&parseFloat(i)===0;r&&!this._bodyMarginsApplied||(this.tabTrapper.style.setProperty("--swc-body-margins-inline",`calc(${e} + ${t})`),this.tabTrapper.style.setProperty("--swc-body-margins-block",`calc(${o} + ${i})`),this._bodyMarginsApplied=!r)}startTabTrapping(){this.initTabTrapping(),this.canTabTrap&&(this.tabTrapper.tabIndex=-1,this.tabTrapper.setAttribute("aria-hidden","true"))}stopTabTrapping(){!this.canTabTrap||!this.trappingInited||(this.tabTrapper.removeAttribute("tabindex"),this.tabTrapper.removeAttribute("aria-hidden"))}get document(){return this.root.ownerDocument||document}get topOverlay(){return this.overlays.slice(-1)[0]}findOverlayForContent(e){for(const t of this.overlays)if(e===t.overlayContent)return t}addEventListeners(){this._eventsAreBound||(this._eventsAreBound=!0,this.document.addEventListener("click",this.handleMouseCapture,!0),this.document.addEventListener("click",this.handleMouse),this.document.addEventListener("keydown",this.handleKeydown),this.document.addEventListener("sp-overlay-close",this.handleOverlayClose),window.addEventListener("resize",this.handleResize))}isClickOverlayActiveForTrigger(e){return this.overlays.some(t=>e===t.trigger&&t.interaction==="click")}async openOverlay(e){if(this.addEventListeners(),this.findOverlayForContent(e.content))return!1;e.notImmediatelyClosable&&(this._doesNotCloseOnFirstClick=!0),e.interaction==="modal"&&this.startTabTrapping();const t=e.content,{trigger:o}=e;if(t.overlayWillOpenCallback&&t.overlayWillOpenCallback({trigger:o}),e.delayed){const n=[this.overlayTimer.openTimer(e.content)];e.abortPromise&&n.push(e.abortPromise);const a=await Promise.race(n);if(a)return t.overlayOpenCancelledCallback&&t.overlayOpenCancelledCallback({trigger:o}),a}if(e.root&&this.closeOverlaysForRoot(e.root),e.interaction==="click")this.closeAllHoverOverlays();else if(e.interaction==="hover"&&this.isClickOverlayActiveForTrigger(e.trigger))return!0;const i=g.create(e);this.overlays.length&&this.overlays[this.overlays.length-1].obscure(i.interaction),document.body.appendChild(i),await u(),this.overlays.push(i),await i.updateComplete,this.addOverlayEventListeners(i),typeof t.open<"u"&&(await u(),t.open=!0);let r=()=>{};if(t.overlayOpenCallback){const{trigger:n}=i,{overlayOpenCallback:a}=t;r=async()=>await a({trigger:n})}return await i.openCallback(r),!1}addOverlayEventListeners(e){switch(e.addEventListener("close",()=>{this.hideAndCloseOverlay(e,!0)}),e.interaction){case"replace":this.addReplaceOverlayEventListeners(e);break;case"inline":this.addInlineOverlayEventListeners(e);break}}addReplaceOverlayEventListeners(e){e.addEventListener("keydown",t=>{const{code:o}=t;o==="Tab"&&(t.stopPropagation(),this.closeOverlay(e.overlayContent),e.tabbingAway=!0,e.trigger.focus(),e.trigger.dispatchEvent(new KeyboardEvent("keydown",t)))})}addInlineOverlayEventListeners(e){e.trigger.addEventListener("keydown",e.handleInlineTriggerKeydown),e.addEventListener("keydown",t=>{const{code:o,shiftKey:i}=t;if(o!=="Tab")return;if(e.tabbingAway=!0,i){const n=document.createElement("span");n.tabIndex=-1,e.trigger.hasAttribute("slot")&&(n.slot=e.trigger.slot),e.trigger.insertAdjacentElement("afterend",n),n.focus(),n.remove();return}t.stopPropagation();const r=e.trigger;typeof r.open<"u"&&(r.open=!1),this.closeOverlay(e.overlayContent),e.trigger.focus()})}closeOverlay(e){this.overlayTimer.close(e),requestAnimationFrame(()=>{const t=this.findOverlayForContent(e),o=[t];o.push(...y(t,this.overlays)),o.forEach(i=>this.hideAndCloseOverlay(i))})}closeAllHoverOverlays(){for(const e of this.overlays)e.interaction==="hover"&&this.hideAndCloseOverlay(e,!1)}closeOverlaysForRoot(e){const t=[];for(const o of this.overlays)o.root&&o.root===e&&(t.push(o),t.push(...y(o,this.overlays)));t.forEach(o=>this.hideAndCloseOverlay(o,!0,!0))}async manageFocusAfterCloseWhenOverlaysRemain(e,t){const o=this.overlays[this.overlays.length-1];if(o.feature(),o.interaction==="modal"||o.hasModalRoot){if(e)return;await(t||o).focus()}else this.stopTabTrapping()}manageFocusAfterCloseWhenLastOverlay(e){this.stopTabTrapping();const t=e.interaction==="modal",o=e.receivesFocus==="auto",i=e.interaction==="replace",r=e.interaction==="inline",n=(i||r)&&!e.tabbingAway;if(e.tabbingAway=!1,!t&&!o&&!n)return;const a=e.overlayContent.getRootNode().activeElement;let l,c;const h=()=>e.overlayContent.contains(a),p=()=>(l=e.trigger.getRootNode(),c=l.activeElement,l.contains(c)),m=()=>l.host&&l.host===c;(t||h()||p()||m())&&e.trigger.focus()}async hideAndCloseOverlay(e,t,o){if(!e)return;const i=e.overlayContent;if(typeof i.overlayWillCloseCallback<"u"){const{trigger:n}=e;if(i.overlayWillCloseCallback({trigger:n}))return}if(await e.hide(t),typeof i.open<"u"&&(i.open=!1),i.overlayCloseCallback){const{trigger:n}=e;await i.overlayCloseCallback({trigger:n})}if(e.state!="dispose")return;const r=this.overlays.indexOf(e);r>=0&&this.overlays.splice(r,1),this.overlays.length?await this.manageFocusAfterCloseWhenOverlaysRemain(o||e.interaction==="hover",e.trigger):this.manageFocusAfterCloseWhenLastOverlay(e),await e.updateComplete,e.remove(),e.dispose(),e.trigger.dispatchEvent(new CustomEvent("sp-closed",{bubbles:!0,composed:!0,cancelable:!0,detail:{interaction:e.interaction}}))}closeTopOverlay(){return this.hideAndCloseOverlay(this.topOverlay,!0)}}const d=class{constructor(s,e,t){this.isOpen=!1,this.owner=s,this.overlayElement=t,this.interaction=e}static async open(s,e,t,o){const i=new d(s,e,t);return await i.open(o),()=>{i.close()}}static update(){const s=new CustomEvent("sp-update-overlays",{bubbles:!0,composed:!0,cancelable:!0});document.dispatchEvent(s)}async open({abortPromise:s,delayed:e,offset:t=0,placement:o="top",receivesFocus:i,notImmediatelyClosable:r,virtualTrigger:n,root:a}){if(this.isOpen)return!0;e===void 0&&(e=this.overlayElement.hasAttribute("delayed"));const l={color:void 0,scale:void 0,lang:void 0,theme:void 0},c=new CustomEvent("sp-query-theme",{bubbles:!0,composed:!0,detail:l,cancelable:!0});this.owner.dispatchEvent(c);const h={},p=new CustomEvent("sp-overlay-query",{bubbles:!0,composed:!0,detail:h,cancelable:!0});return this.overlayElement.dispatchEvent(p),await d.overlayStack.openOverlay({abortPromise:s,content:this.overlayElement,contentTip:h.overlayContentTipElement,delayed:e,offset:t,placement:o,trigger:this.owner,interaction:this.interaction,theme:l,receivesFocus:i,root:a,notImmediatelyClosable:r,virtualTrigger:n,...h}),this.isOpen=!0,!0}close(){d.overlayStack.closeOverlay(this.overlayElement)}};let O=d;O.overlayStack=new T;export{O as Overlay};
